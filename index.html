<!DOCTYPE html>
<html>
<head>
  <meta charset="UTF-8">
  <title>thisduck made it myself</title>
  <style>
    body {
      margin: 0;
      overflow: hidden;
      background: black;
      font-family: Arial;
    }

    #crosshair {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      color: white;
      font-size: 26px;
      pointer-events: none;
    }

    /* stamina */
    #staminaBox {
      position: absolute;
      bottom: 20px;
      left: 50%;
      transform: translateX(-50%);
      width: 300px;
      height: 16px;
      border: 2px solid white;
    }
    #stamina {
      height: 100%;
      width: 100%;
      background: #00aaff;
    }

    /* player health */
    #healthBox {
      position: absolute;
      bottom: 50px;
      left: 50%;
      transform: translateX(-50%);
      width: 300px;
      height: 16px;
      border: 2px solid white;
    }
    #health {
      height: 100%;
      width: 100%;
      background: #00ff66;
    }

    /* ammo */
    #ammo {
      position: absolute;
      bottom: 110px;
      left: 50%;
      transform: translateX(-50%);
      color: white;
      font-size: 24px;
      font-family: Arial;
    }
    #reloadText {
      position: absolute;
      bottom: 140px;
      left: 50%;
      transform: translateX(-50%);
      color: yellow;
      font-size: 24px;
      font-family: Arial;
      display: none;
    }

    /* death */
    #death {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: rgba(0,0,0,0.9);
      color: white;
      display: none;
      align-items: center;
      justify-content: center;
      flex-direction: column;
      font-size: 30px;
    }
    button {
      padding: 15px 30px;
      font-size: 20px;
      margin-top: 20px;
      cursor: pointer;
    }
  </style>
</head>
<body>
  <div id="crosshair">+</div>
  <div id="healthBox"><div id="health"></div></div>
  <div id="staminaBox"><div id="stamina"></div></div>
  <div id="ammo">Ammo: 30/30</div>
  <div id="reloadText">Reloading...</div>
  <div id="death">
    <div id="scoreText"></div>
    <div id="highText"></div>
    <button onclick="respawn()">RESPAWN</button>
  </div>

  <script src="https://cdn.jsdelivr.net/npm/three@0.158.0/build/three.min.js"></script>
  <script>
    // ===== SCENE =====
    const scene = new THREE.Scene();

    const textureLoader = new THREE.TextureLoader();
    const cubeTextureLoader = new THREE.CubeTextureLoader();

  scene.background = new THREE.Color(0x87ceeb); // Light blue sky

    // Fog
    scene.fog = new THREE.FogExp2(0x87ceeb, 0.001);

    const camera = new THREE.PerspectiveCamera(75, innerWidth/innerHeight, 0.1, 2000);
    const renderer = new THREE.WebGLRenderer({antialias: true});
    renderer.setSize(innerWidth, innerHeight);
    renderer.shadowMap.enabled = true;
    renderer.shadowMap.type = THREE.PCFSoftShadowMap;
    document.body.appendChild(renderer.domElement);

    // LIGHT
    scene.add(new THREE.AmbientLight(0xffffff, 1.0));
    const sun = new THREE.DirectionalLight(0xffffff, 1);
    sun.position.set(100, 200, 100);
    sun.castShadow = true;
    sun.shadow.mapSize.width = 1024;
    sun.shadow.mapSize.height = 1024;
    sun.shadow.camera.near = 0.5;
    sun.shadow.camera.far = 500;
    sun.shadow.camera.left = -500;
    sun.shadow.camera.right = 500;
    sun.shadow.camera.top = 500;
    sun.shadow.camera.bottom = -500;
    scene.add(sun);

    // ===== GRASS FLOOR =====
    const grassColor = textureLoader.load('https://dl5zpyw5l3y4t.cloudfront.net/archive/Grass004/Grass004_2K_Color.png');
    grassColor.wrapS = grassColor.wrapT = THREE.RepeatWrapping;
    grassColor.repeat.set(100, 100);

    const grassNormal = textureLoader.load('https://dl5zpyw5l3y4t.cloudfront.net/archive/Grass004/Grass004_2K_NormalGL.png');
    grassNormal.wrapS = grassNormal.wrapT = THREE.RepeatWrapping;
    grassNormal.repeat.set(100, 100);

    const grassRough = textureLoader.load('https://dl5zpyw5l3y4t.cloudfront.net/archive/Grass004/Grass004_2K_Roughness.png');
    grassRough.wrapS = grassRough.wrapT = THREE.RepeatWrapping;
    grassRough.repeat.set(100, 100);

    const grassDisp = textureLoader.load('https://dl5zpyw5l3y4t.cloudfront.net/archive/Grass004/Grass004_2K_Displacement.png');
    grassDisp.wrapS = grassDisp.wrapT = THREE.RepeatWrapping;
    grassDisp.repeat.set(100, 100);

    const ground = new THREE.Mesh(
      new THREE.PlaneGeometry(2000, 2000, 200, 200),
      new THREE.MeshStandardMaterial({
        map: grassColor,
        normalMap: grassNormal,
        roughnessMap: grassRough,
        displacementMap: grassDisp,
        displacementScale: 0.1
      })
    );
    ground.rotation.x = -Math.PI / 2;
    ground.receiveShadow = false;
    scene.add(ground);

    // ===== TREES =====
    function createTree(x, z) {
      const tree = new THREE.Group();

      const barkColor = textureLoader.load('https://dl5zpyw5l3y4t.cloudfront.net/archive/Bark009/Bark009_2K_Color.png');
      barkColor.wrapS = barkColor.wrapT = THREE.RepeatWrapping;
      barkColor.repeat.set(1, 3);

      const barkNormal = textureLoader.load('https://dl5zpyw5l3y4t.cloudfront.net/archive/Bark009/Bark009_2K_NormalGL.png');
      barkNormal.wrapS = barkNormal.wrapT = THREE.RepeatWrapping;
      barkNormal.repeat.set(1, 3);

      const trunk = new THREE.Mesh(
        new THREE.CylinderGeometry(0.4, 0.5, 5, 10),
        new THREE.MeshStandardMaterial({
          map: barkColor,
          normalMap: barkNormal
        })
      );
      trunk.position.y = 2.5;
      trunk.castShadow = true;
      tree.add(trunk);

      const leavesMaterial = new THREE.MeshStandardMaterial({color: 0x228B22});

      const leaves1 = new THREE.Mesh(
        new THREE.SphereGeometry(2, 16, 16),
        leavesMaterial
      );
      leaves1.position.y = 4;
      leaves1.castShadow = true;
      tree.add(leaves1);

      const leaves2 = new THREE.Mesh(
        new THREE.SphereGeometry(2.5, 16, 16),
        leavesMaterial
      );
      leaves2.position.y = 5.5;
      leaves2.castShadow = true;
      tree.add(leaves2);

      const leaves3 = new THREE.Mesh(
        new THREE.SphereGeometry(2, 16, 16),
        leavesMaterial
      );
      leaves3.position.y = 7;
      leaves3.castShadow = true;
      tree.add(leaves3);

      tree.position.set(x, 0, z);
      scene.add(tree);
    }
    for (let i = 0; i < 200; i++) {
      createTree((Math.random() - 0.5) * 800, (Math.random() - 0.5) * 800);
    }

    // ===== PLAYER =====
    const player = new THREE.Object3D();
    player.position.set(0, 5, 20);
    scene.add(player);
    player.add(camera);

    let yaw = 0, pitch = 0;
    let keys = {};

    let stamina = 100;
    let health = 3;
    let damageCooldown = 0;
    let dead = false;
    let respawnProtection = 0;
    let velY = 0;
    let onGround = true;
    let score = 0, highscore = 0;

    // ===== WEAPON SYSTEM =====
    const weapons = {
      ak: {
        name: "AK",
        ammo: 30,
        maxAmmo: 30,
        reloadTime: 90,
        damage: 20,
        shotsToKill: 5,
        model: null
      },
      shotgun: {
        name: "Shotgun",
        ammo: 6,
        maxAmmo: 6,
        reloadTime: 60,
        damage: 50,
        shotsToKill: 2,
        model: null
      },
      sniper: {
        name: "Sniper",
        ammo: 1,
        maxAmmo: 1,
        reloadTime: 240,
        damage: 100,
        shotsToKill: 1,
        model: null
      }
    };

    let currentWeapon = weapons.ak;
    let reloading = false;
    let reloadCounter = 0;

    // Create more realistic gun models using primitives
    function createWeaponModels() {
      // AK-47 Model
      const ak = new THREE.Group();

      // Barrel
      const akBarrel = new THREE.Mesh(
        new THREE.CylinderGeometry(0.03, 0.03, 0.6, 16),
        new THREE.MeshStandardMaterial({color: 0x333333, metalness: 0.8, roughness: 0.2})
      );
      akBarrel.rotation.x = Math.PI / 2;
      akBarrel.position.set(0, 0, -0.6);
      ak.add(akBarrel);

      // Muzzle
      const akMuzzle = new THREE.Mesh(
        new THREE.CylinderGeometry(0.04, 0.04, 0.1, 16),
        new THREE.MeshStandardMaterial({color: 0x222222, metalness: 0.8, roughness: 0.2})
      );
      akMuzzle.rotation.x = Math.PI / 2;
      akMuzzle.position.set(0, 0, -0.95);
      ak.add(akMuzzle);

      // Receiver/Body
      const akReceiver = new THREE.Mesh(
        new THREE.BoxGeometry(0.15, 0.12, 0.4),
        new THREE.MeshStandardMaterial({color: 0x444444, metalness: 0.7, roughness: 0.3})
      );
      akReceiver.position.set(0, 0, -0.2);
      ak.add(akReceiver);

      // Stock
      const akStock = new THREE.Mesh(
        new THREE.BoxGeometry(0.12, 0.08, 0.5),
        new THREE.MeshStandardMaterial({color: 0x8b4513, roughness: 0.5})
      );
      akStock.position.set(0, -0.02, 0.25);
      ak.add(akStock);

      // Magazine (curved approximation)
      const akMag = new THREE.Mesh(
        new THREE.BoxGeometry(0.08, 0.25, 0.15),
        new THREE.MeshStandardMaterial({color: 0x111111, metalness: 0.9, roughness: 0.1})
      );
      akMag.position.set(0, -0.15, -0.3);
      akMag.rotation.z = Math.PI / 6; // Tilt for curve
      ak.add(akMag);

      // Grip
      const akGrip = new THREE.Mesh(
        new THREE.BoxGeometry(0.08, 0.15, 0.08),
        new THREE.MeshStandardMaterial({color: 0x8b4513, roughness: 0.5})
      );
      akGrip.position.set(0, -0.1, -0.05);
      ak.add(akGrip);

      // Handguard
      const akHandguard = new THREE.Mesh(
        new THREE.BoxGeometry(0.1, 0.1, 0.3),
        new THREE.MeshStandardMaterial({color: 0x8b4513, roughness: 0.5})
      );
      akHandguard.position.set(0, 0, -0.5);
      ak.add(akHandguard);

      weapons.ak.model = ak;

      // Shotgun Model
      const sg = new THREE.Group();

      // Barrel (long)
      const sgBarrel = new THREE.Mesh(
        new THREE.CylinderGeometry(0.04, 0.04, 0.8, 16),
        new THREE.MeshStandardMaterial({color: 0x333333, metalness: 0.8, roughness: 0.2})
      );
      sgBarrel.rotation.x = Math.PI / 2;
      sgBarrel.position.set(0, 0, -0.7);
      sg.add(sgBarrel);

      // Pump
      const sgPump = new THREE.Mesh(
        new THREE.CylinderGeometry(0.06, 0.06, 0.3, 16),
        new THREE.MeshStandardMaterial({color: 0x444444, metalness: 0.7, roughness: 0.3})
      );
      sgPump.rotation.x = Math.PI / 2;
      sgPump.position.set(0, -0.05, -0.4);
      sg.add(sgPump);

      // Receiver
      const sgReceiver = new THREE.Mesh(
        new THREE.BoxGeometry(0.15, 0.15, 0.3),
        new THREE.MeshStandardMaterial({color: 0x222222, metalness: 0.8, roughness: 0.2})
      );
      sgReceiver.position.set(0, 0, -0.15);
      sg.add(sgReceiver);

      // Stock
      const sgStock = new THREE.Mesh(
        new THREE.BoxGeometry(0.12, 0.1, 0.5),
        new THREE.MeshStandardMaterial({color: 0x8b4513, roughness: 0.5})
      );
      sgStock.position.set(0, 0, 0.25);
      sg.add(sgStock);

      // Grip
      const sgGrip = new THREE.Mesh(
        new THREE.BoxGeometry(0.08, 0.2, 0.1),
        new THREE.MeshStandardMaterial({color: 0x111111, metalness: 0.9, roughness: 0.1})
      );
      sgGrip.position.set(0, -0.12, 0);
      sg.add(sgGrip);

      weapons.shotgun.model = sg;

      // Sniper Rifle Model
      const sn = new THREE.Group();

      // Long Barrel
      const snBarrel = new THREE.Mesh(
        new THREE.CylinderGeometry(0.03, 0.03, 1.0, 16),
        new THREE.MeshStandardMaterial({color: 0x333333, metalness: 0.8, roughness: 0.2})
      );
      snBarrel.rotation.x = Math.PI / 2;
      snBarrel.position.set(0, 0, -0.8);
      sn.add(snBarrel);

      // Muzzle Brake
      const snMuzzle = new THREE.Mesh(
        new THREE.CylinderGeometry(0.05, 0.05, 0.15, 16),
        new THREE.MeshStandardMaterial({color: 0x222222, metalness: 0.8, roughness: 0.2})
      );
      snMuzzle.rotation.x = Math.PI / 2;
      snMuzzle.position.set(0, 0, -1.3);
      sn.add(snMuzzle);

      // Body/Receiver
      const snReceiver = new THREE.Mesh(
        new THREE.BoxGeometry(0.15, 0.12, 0.4),
        new THREE.MeshStandardMaterial({color: 0x444444, metalness: 0.7, roughness: 0.3})
      );
      snReceiver.position.set(0, 0, -0.2);
      sn.add(snReceiver);

      // Stock with cheek rest
      const snStock = new THREE.Mesh(
        new THREE.BoxGeometry(0.12, 0.1, 0.6),
        new THREE.MeshStandardMaterial({color: 0x111111, metalness: 0.9, roughness: 0.1})
      );
      snStock.position.set(0, 0, 0.3);
      sn.add(snStock);

      const snCheek = new THREE.Mesh(
        new THREE.BoxGeometry(0.1, 0.05, 0.2),
        new THREE.MeshStandardMaterial({color: 0x111111, metalness: 0.9, roughness: 0.1})
      );
      snCheek.position.set(0, 0.08, 0.2);
      sn.add(snCheek);

      // Scope
      const snScope = new THREE.Mesh(
        new THREE.CylinderGeometry(0.04, 0.04, 0.3, 16),
        new THREE.MeshStandardMaterial({color: 0x000000, metalness: 0.5, roughness: 0.4})
      );
      snScope.rotation.x = Math.PI / 2;
      snScope.position.set(0, 0.1, -0.3);
      sn.add(snScope);

      // Bipod (simple)
      const bipodLeg1 = new THREE.Mesh(
        new THREE.BoxGeometry(0.02, 0.2, 0.02),
        new THREE.MeshStandardMaterial({color: 0x333333, metalness: 0.8, roughness: 0.2})
      );
      bipodLeg1.position.set(-0.05, -0.1, -0.5);
      bipodLeg1.rotation.z = Math.PI / 6;
      sn.add(bipodLeg1);

      const bipodLeg2 = new THREE.Mesh(
        new THREE.BoxGeometry(0.02, 0.2, 0.02),
        new THREE.MeshStandardMaterial({color: 0x333333, metalness: 0.8, roughness: 0.2})
      );
      bipodLeg2.position.set(0.05, -0.1, -0.5);
      bipodLeg2.rotation.z = -Math.PI / 6;
      sn.add(bipodLeg2);

      weapons.sniper.model = sn;
    }
    createWeaponModels();
    camera.add(currentWeapon.model);
    currentWeapon.model.position.set(0.35, -0.35, -0.6);

    // Weapon switching
    addEventListener("keydown", e => {
      keys[e.key.toLowerCase()] = true;
      if (e.key === "1") switchWeapon("ak");
      if (e.key === "2") switchWeapon("shotgun");
      if (e.key === "3") switchWeapon("sniper");

      if (e.key.toLowerCase() === "r" && !reloading && currentWeapon.ammo < currentWeapon.maxAmmo) {
        reloading = true;
        reloadCounter = currentWeapon.reloadTime;
        document.getElementById("reloadText").style.display = "block";
      }
    });
    addEventListener("keyup", e => keys[e.key.toLowerCase()] = false);

    function switchWeapon(name) {
      if (currentWeapon.model) camera.remove(currentWeapon.model);
      currentWeapon = weapons[name];
      camera.add(currentWeapon.model);
      currentWeapon.model.position.set(0.35, -0.35, -0.6);
      document.getElementById("ammo").innerText = `Ammo: ${currentWeapon.ammo}/${currentWeapon.maxAmmo}`;
    }

    // ===== MOUSE CONTROL =====
    renderer.domElement.onclick = () => renderer.domElement.requestPointerLock();
    addEventListener("mousemove", e => {
      if (document.pointerLockElement === renderer.domElement && !dead) {
        yaw -= e.movementX * 0.0025;
        pitch -= e.movementY * 0.0025;
        pitch = Math.max(-1.5, Math.min(1.5, pitch));
      }
    });

    // ===== NPC SYSTEM =====
    let npcs = [];
    let bullets = [];

    function createHealthBar() {
      const bar = new THREE.Group();
      const bg = new THREE.Mesh(new THREE.PlaneGeometry(2, 0.25), new THREE.MeshBasicMaterial({color: 0xff0000}));
      bar.add(bg);
      const hp = new THREE.Mesh(new THREE.PlaneGeometry(2, 0.25), new THREE.MeshBasicMaterial({color: 0x00ff00}));
      hp.position.z = 0.01;
      bar.add(hp);
      bar.hp = hp;
      bar.position.y = 3.4;
      return bar;
    }

    function spawnNPC() {
      const npc = new THREE.Group();
      const body = new THREE.Mesh(new THREE.BoxGeometry(1.5, 2, 1), new THREE.MeshStandardMaterial({color: 0xaa0000}));
      body.position.y = 1;
      body.castShadow = true;
      npc.add(body);
      const head = new THREE.Mesh(new THREE.BoxGeometry(0.9, 0.9, 0.9), new THREE.MeshStandardMaterial({color: 0xff4444}));
      head.position.y = 2.3;
      head.castShadow = true;
      npc.add(head);
      npc.health = 100;
      const hp = createHealthBar();
      npc.add(hp);
      npc.hpbar = hp;
      npc.position.set((Math.random() - 0.5) * 400, 0, (Math.random() - 0.5) * 400);
      npc.cool = 0;
      scene.add(npc);
      npcs.push(npc);
      // Initial health bar setup (though default is fine)
      npc.hpbar.hp.scale.x = npc.health / 100;
      npc.hpbar.hp.position.x = -1 + (npc.health / 100);
    }
    function maintainNPCs() {
      while (npcs.length < 10) spawnNPC();
    }
    maintainNPCs();

    // ===== RAYCAST SHOOTING =====
    const raycaster = new THREE.Raycaster();
    addEventListener("mousedown", e => {
      if (e.button === 0 && !dead) shoot();
    });

    function shoot() {
      if (reloading || currentWeapon.ammo <= 0) return;
      currentWeapon.ammo--;
      document.getElementById("ammo").innerText = `Ammo: ${currentWeapon.ammo}/${currentWeapon.maxAmmo}`;

      // recoil animation
      currentWeapon.model.position.z -= 0.15;
      setTimeout(() => currentWeapon.model.position.z += 0.15, 80);

      // Muzzle flash
      const flash = new THREE.PointLight(0xffaa00, 2, 10);
      flash.position.set(0.35, -0.35, -1);
      camera.add(flash);
      setTimeout(() => camera.remove(flash), 50);

      raycaster.setFromCamera(new THREE.Vector2(0, 0), camera);
      const hits = raycaster.intersectObjects(npcs, true);
      if (hits.length > 0) {
        const enemy = hits[0].object.parent;
        if (currentWeapon.name === "sniper") {
          enemy.health = 0; // one-shot
        } else {
          enemy.health -= currentWeapon.damage;
        }
        const fraction = enemy.health / 100;
        enemy.hpbar.hp.scale.x = fraction;
        enemy.hpbar.hp.position.x = -1 + fraction;
        if (enemy.health <= 0) {
          scene.remove(enemy);
          npcs.splice(npcs.indexOf(enemy), 1);
          score++;
        }
      }
    }

    // ===== ENEMY SHOOT =====
    function enemyShoot(npc) {
      const b = new THREE.Mesh(new THREE.SphereGeometry(0.25, 8, 8), new THREE.MeshBasicMaterial({color: "red"}));
      b.position.copy(npc.position);
      b.userData = {vel: player.position.clone().sub(npc.position).normalize().multiplyScalar(0.7)};
      scene.add(b);
      bullets.push(b);
    }

    // ===== PLAYER DAMAGE =====
    function damagePlayer() {
      if (respawnProtection > 0 || damageCooldown > 0) return;
      health--;
      damageCooldown = 45;
      document.getElementById("health").style.width = (health / 3 * 100) + "%";
      if (health <= 0) die();
    }

    // ===== DEATH =====
    function die() {
      dead = true;
      document.exitPointerLock();
      document.getElementById("death").style.display = "flex";
      if (score > highscore) highscore = score;
      document.getElementById("scoreText").innerText = "Score: " + score;
      document.getElementById("highText").innerText = "High Score: " + highscore;
    }

    // ===== RESPAWN =====
    function respawn() {
      dead = false;
      score = 0;
      health = 3;
      document.getElementById("health").style.width = "100%";
      player.position.set(0, 5, 20);
      yaw = 0;
      pitch = 0;
      bullets.forEach(b => scene.remove(b));
      bullets = [];
      npcs.forEach(n => scene.remove(n));
      npcs = [];
      maintainNPCs();
      respawnProtection = 180;
      document.getElementById("death").style.display = "none";
      renderer.domElement.requestPointerLock();
    }

    // ===== HANDLE RELOAD =====
    function handleReload() {
      if (reloading) {
        reloadCounter--;
        if (reloadCounter <= 0) {
          currentWeapon.ammo = currentWeapon.maxAmmo;
          reloading = false;
          document.getElementById("ammo").innerText = `Ammo: ${currentWeapon.ammo}/${currentWeapon.maxAmmo}`;
          document.getElementById("reloadText").style.display = "none";
        }
      }
    }

    // ===== UPDATE LOOP =====
    function update() {
      if (damageCooldown > 0) damageCooldown--;
      handleReload();
      if (dead) return;
      if (respawnProtection > 0) respawnProtection--;

      player.rotation.y = yaw;
      camera.rotation.x = pitch;

      // sprint
      let sprint = keys["shift"] && stamina > 0;
      let speed = sprint ? 0.6 : 0.25;
      if (sprint) stamina -= 0.7;
      else stamina += 0.4;
      stamina = Math.max(0, Math.min(100, stamina));
      document.getElementById("stamina").style.width = stamina + "%";

      const forward = new THREE.Vector3(0, 0, -1).applyQuaternion(player.quaternion);
      const right = new THREE.Vector3(1, 0, 0).applyQuaternion(player.quaternion);
      if (keys["w"]) player.position.add(forward.clone().multiplyScalar(speed));
      if (keys["s"]) player.position.add(forward.clone().multiplyScalar(-speed));
      if (keys["a"]) player.position.add(right.clone().multiplyScalar(-speed));
      if (keys["d"]) player.position.add(right.clone().multiplyScalar(speed));

      // jump
      if (keys[" "] && onGround) {
        velY = 0.35;
        onGround = false;
      }
      velY -= 0.02;
      player.position.y += velY;
      if (player.position.y <= 5) {
        player.position.y = 5;
        velY = 0;
        onGround = true;
      }

      // NPC behavior
      npcs.forEach(n => {
        const dist = n.position.distanceTo(player.position);
        n.hpbar.quaternion.copy(camera.quaternion);
        n.cool--;
        if (dist < 120 && n.cool <= 0) {
          enemyShoot(n);
          n.cool = 120;
        }
      });
      maintainNPCs();

      // bullets
      bullets.forEach(b => {
        b.position.add(b.userData.vel);
        if (b.position.distanceTo(player.position) < 1.5) {
          damagePlayer();
          scene.remove(b);
        }
      });
    }

    // ===== ANIMATION LOOP =====
    function animate() {
      requestAnimationFrame(animate);
      update();
      renderer.render(scene, camera);
    }
    animate();

    // ===== RESIZE =====
    addEventListener("resize", () => {
      camera.aspect = innerWidth / innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(innerWidth, innerHeight);
    });
  </script>
</body>
</html>