<!DOCTYPE html>
<html>
<head>
  <meta charset="UTF-8">
  <title>thisduck made it myself</title>
  <style>
    body {
      margin: 0;
      overflow: hidden;
      background: black;
      font-family: Arial;
    }

    #crosshair {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      color: white;
      font-size: 26px;
      pointer-events: none;
    }

    /* stamina */
    #staminaBox {
      position: absolute;
      bottom: 20px;
      left: 50%;
      transform: translateX(-50%);
      width: 300px;
      height: 16px;
      border: 2px solid white;
    }
    #stamina {
      height: 100%;
      width: 100%;
      background: #00aaff;
    }

    /* player health */
    #healthBox {
      position: absolute;
      bottom: 50px;
      left: 50%;
      transform: translateX(-50%);
      width: 300px;
      height: 16px;
      border: 2px solid white;
    }
    #health {
      height: 100%;
      width: 100%;
      background: #00ff66;
    }

    /* ammo */
    #ammo {
      position: absolute;
      bottom: 110px;
      left: 50%;
      transform: translateX(-50%);
      color: white;
      font-size: 24px;
      font-family: Arial;
    }
    #reloadText {
      position: absolute;
      bottom: 140px;
      left: 50%;
      transform: translateX(-50%);
      color: yellow;
      font-size: 24px;
      font-family: Arial;
      display: none;
    }

    /* controls (top-left) */
    #controls {
      position: absolute;
      top: 10px;
      left: 10px;
      color: white;
      font-size: 14px;
      background: rgba(0,0,0,0.45);
      padding: 8px 10px;
      border-radius: 6px;
      line-height: 1.35;
      text-transform: none;
    }

    /* score (top-right) */
    #hudTopRight {
      position: absolute;
      top: 10px;
      right: 10px;
      color: white;
      text-align: right;
      background: rgba(0,0,0,0.45);
      padding: 8px 10px;
      border-radius: 6px;
      font-size: 14px;
    }
    #hudTopRight div { line-height: 1.2; }

    /* death */
    #death {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: rgba(0,0,0,0.9);
      color: white;
      display: none;
      align-items: center;
      justify-content: center;
      flex-direction: column;
      font-size: 30px;
    }
    button {
      padding: 15px 30px;
      font-size: 20px;
      margin-top: 20px;
      cursor: pointer;
    }
  </style>
</head>
<body>
  <div id="crosshair">+</div>
  <div id="healthBox"><div id="health"></div></div>
  <div id="staminaBox"><div id="stamina"></div></div>
  <div id="ammo">Ammo: 30/30</div>
  <div id="reloadText">Reloading...</div>

  <div id="controls">
    <div>Cycle through weapons: 1 2 3</div>
    <div>Sprint: SHIFT</div>
    <div>Jump: SPACE</div>
    <div>Move: W A S D</div>
  </div>

  <div id="hudTopRight">
    <div id="currentScore">Score: 0</div>
    <div id="highScore">High Score: 0</div>
  </div>

  <div id="death">
    <div id="scoreText"></div>
    <div id="highText"></div>
    <button onclick="respawn()">RESPAWN</button>
  </div>

  <script src="https://cdn.jsdelivr.net/npm/three@0.158.0/build/three.min.js"></script>
  <script>
    // ===== SCENE =====
    const scene = new THREE.Scene();

    const textureLoader = new THREE.TextureLoader();
    const cubeTextureLoader = new THREE.CubeTextureLoader();

  scene.background = new THREE.Color(0x87ceeb); // Light blue sky

    // Fog
    scene.fog = new THREE.FogExp2(0x87ceeb, 0.001);

    const camera = new THREE.PerspectiveCamera(75, innerWidth/innerHeight, 0.1, 2000);
    const renderer = new THREE.WebGLRenderer({antialias: true});
    renderer.setSize(innerWidth, innerHeight);
    renderer.shadowMap.enabled = true;
    renderer.shadowMap.type = THREE.PCFSoftShadowMap;
    // ensure colors/textures render correctly
    renderer.outputEncoding = THREE.sRGBEncoding;
    document.body.appendChild(renderer.domElement);

    // LIGHT
    scene.add(new THREE.AmbientLight(0xffffff, 1.2));
    const sun = new THREE.DirectionalLight(0xffffff, 1.4);
    sun.position.set(100, 200, 100);
    sun.castShadow = true;
    sun.shadow.mapSize.width = 1024;
    sun.shadow.mapSize.height = 1024;
    sun.shadow.camera.near = 0.5;
    sun.shadow.camera.far = 500;
    sun.shadow.camera.left = -500;
    sun.shadow.camera.right = 500;
    sun.shadow.camera.top = 500;
    sun.shadow.camera.bottom = -500;
    scene.add(sun);

    // ===== GRASS FLOOR =====
    // load textures asynchronously and assign to material when ready
    let grassColor = null, grassNormal = null, grassRough = null, grassDisp = null;
    let grassColorLoaded = false;
    const grassBaseUrl = 'https://dl5zpyw5l3y4t.cloudfront.net/archive/Grass004/';

    textureLoader.load(grassBaseUrl + 'Grass004_2K_Color.png', tex => {
      grassColor = tex; grassColor.wrapS = grassColor.wrapT = THREE.RepeatWrapping; grassColor.repeat.set(100,100); grassColor.encoding = THREE.sRGBEncoding; grassColorLoaded = true;
      if (typeof ground !== 'undefined' && ground.material) { ground.material.map = grassColor; ground.material.needsUpdate = true; }
    }, undefined, err => { console.warn('Grass color failed to load', err); });

    textureLoader.load(grassBaseUrl + 'Grass004_2K_NormalGL.png', tex => { grassNormal = tex; grassNormal.wrapS = grassNormal.wrapT = THREE.RepeatWrapping; grassNormal.repeat.set(100,100); if (typeof ground !== 'undefined' && ground.material) { ground.material.normalMap = grassNormal; ground.material.needsUpdate = true; } }, undefined, err => { console.warn('Grass normal failed to load', err); });

    textureLoader.load(grassBaseUrl + 'Grass004_2K_Roughness.png', tex => { grassRough = tex; grassRough.wrapS = grassRough.wrapT = THREE.RepeatWrapping; grassRough.repeat.set(100,100); if (typeof ground !== 'undefined' && ground.material) { ground.material.roughnessMap = grassRough; ground.material.needsUpdate = true; } }, undefined, err => { console.warn('Grass roughness failed to load', err); });

    textureLoader.load(grassBaseUrl + 'Grass004_2K_Displacement.png', tex => { grassDisp = tex; grassDisp.wrapS = grassDisp.wrapT = THREE.RepeatWrapping; grassDisp.repeat.set(100,100); if (typeof ground !== 'undefined' && ground.material) { ground.material.displacementMap = grassDisp; ground.material.displacementScale = 0.06; ground.material.needsUpdate = true; } }, undefined, err => { console.warn('Grass displacement failed to load', err); });

    // Ground with grass texture fallback to solid green if textures fail
    const groundMat = new THREE.MeshStandardMaterial({
      map: grassColor,
      normalMap: grassNormal,
      roughnessMap: grassRough,
      displacementMap: grassDisp,
      displacementScale: 0.06,
      color: 0x2e8b57,
      roughness: 0.95
    });
    // if texture exists, ensure correct encoding
    if (grassColor) grassColor.encoding = THREE.sRGBEncoding;

    const ground = new THREE.Mesh(
      new THREE.PlaneGeometry(2000, 2000, 200, 200),
      groundMat
    );
    ground.rotation.x = -Math.PI / 2;
    ground.receiveShadow = true;
    ground.castShadow = false;
    scene.add(ground);

    // Ensure a visible fallback if textures fail to load or CORS blocks them
    setTimeout(() => {
      if (!grassColor || !grassColor.image) {
        ground.material.map = null;
        ground.material.normalMap = null;
        ground.material.roughnessMap = null;
        ground.material.displacementMap = null;
        ground.material.color.set(0x39b54a);
        ground.material.roughness = 0.8;
        ground.material.needsUpdate = true;
        console.warn('Ground textures not available; using solid green fallback.');
      }
    }, 1200);

    // ===== TREES =====
    function createTree(x, z) {
      const tree = new THREE.Group();

      const barkColor = textureLoader.load('https://dl5zpyw5l3y4t.cloudfront.net/archive/Bark009/Bark009_2K_Color.png');
      barkColor.wrapS = barkColor.wrapT = THREE.RepeatWrapping;
      barkColor.repeat.set(1, 3);

      const barkNormal = textureLoader.load('https://dl5zpyw5l3y4t.cloudfront.net/archive/Bark009/Bark009_2K_NormalGL.png');
      barkNormal.wrapS = barkNormal.wrapT = THREE.RepeatWrapping;
      barkNormal.repeat.set(1, 3);

      const trunk = new THREE.Mesh(
        new THREE.CylinderGeometry(0.4, 0.5, 5, 10),
        new THREE.MeshStandardMaterial({
          map: barkColor,
          normalMap: barkNormal
        })
      );
      trunk.position.y = 2.5;
      trunk.castShadow = true;
      tree.add(trunk);

      const leavesMaterial = new THREE.MeshStandardMaterial({color: 0x228B22});

      const leaves1 = new THREE.Mesh(
        new THREE.SphereGeometry(2, 16, 16),
        leavesMaterial
      );
      leaves1.position.y = 4;
      leaves1.castShadow = true;
      tree.add(leaves1);

      const leaves2 = new THREE.Mesh(
        new THREE.SphereGeometry(2.5, 16, 16),
        leavesMaterial
      );
      leaves2.position.y = 5.5;
      leaves2.castShadow = true;
      tree.add(leaves2);

      const leaves3 = new THREE.Mesh(
        new THREE.SphereGeometry(2, 16, 16),
        leavesMaterial
      );
      leaves3.position.y = 7;
      leaves3.castShadow = true;
      tree.add(leaves3);

      tree.position.set(x, 0, z);
      scene.add(tree);
    }
    for (let i = 0; i < 200; i++) {
      createTree((Math.random() - 0.5) * 800, (Math.random() - 0.5) * 800);
    }

    // ===== PLAYER =====
    const player = new THREE.Object3D();
    player.position.set(0, 5, 20);
    scene.add(player);
    player.add(camera);

    let yaw = 0, pitch = 0;
    let keys = {};
    // sanity timer to periodically prune camera children to avoid visual glitches
    let cameraSanityTimer = 0;

    let stamina = 100;
    let health = 3;
    let damageCooldown = 0;
    let dead = false;
    let respawnProtection = 0;
    let velY = 0;
    let onGround = true;
    let score = 0, highscore = 0;

    // ===== WEAPON SYSTEM =====
    const weapons = {
      ak: {
        name: "AK",
        ammo: 30,
        maxAmmo: 30,
        reloadTime: 90,
        damage: 20,
        shotsToKill: 5,
        model: null
      },
      shotgun: {
        name: "Shotgun",
        ammo: 6,
        maxAmmo: 6,
        reloadTime: 60,
        damage: 50,
        shotsToKill: 2,
        model: null
      },
      sniper: {
        name: "Sniper",
        ammo: 1,
        maxAmmo: 1,
        reloadTime: 240,
        damage: 100,
        shotsToKill: 1,
        model: null
      }
    };

    let currentWeapon = weapons.ak;
    let reloading = false;
    let reloadCounter = 0;

    // Create more realistic gun models using primitives
    function createWeaponModels() {
      // Helper materials
      const metal = new THREE.MeshStandardMaterial({color: 0x33353b, metalness: 0.9, roughness: 0.25});
      const darkMetal = new THREE.MeshStandardMaterial({color: 0x1f1f20, metalness: 0.95, roughness: 0.15});
      const wood = new THREE.MeshStandardMaterial({color: 0x6f3f1e, metalness: 0.1, roughness: 0.6});
      const black = new THREE.MeshStandardMaterial({color: 0x0b0b0b, metalness: 0.8, roughness: 0.2});

      // AK-47 Model (more detailed)
      const ak = new THREE.Group();

      // Main barrel
      const akBarrel = new THREE.Mesh(new THREE.CylinderGeometry(0.03, 0.03, 0.8, 18), metal);
      akBarrel.rotation.x = Math.PI / 2;
      akBarrel.position.set(0, 0, -0.9);
      ak.add(akBarrel);

      // Muzzle
      const akMuzzle = new THREE.Mesh(new THREE.CylinderGeometry(0.045, 0.045, 0.18, 12), darkMetal);
      akMuzzle.rotation.x = Math.PI / 2;
      akMuzzle.position.set(0, 0, -1.25);
      ak.add(akMuzzle);

      // Receiver
      const akReceiver = new THREE.Mesh(new THREE.BoxGeometry(0.22, 0.12, 0.45), metal);
      akReceiver.position.set(0, -0.02, -0.35);
      ak.add(akReceiver);

      // Top rail/sight
      const akRail = new THREE.Mesh(new THREE.BoxGeometry(0.15, 0.03, 0.5), darkMetal);
      akRail.position.set(0, 0.06, -0.45);
      ak.add(akRail);

      // Wooden stock
      const akStock = new THREE.Mesh(new THREE.BoxGeometry(0.14, 0.08, 0.6), wood);
      akStock.position.set(0.04, -0.04, 0.25);
      akStock.rotation.x = -0.05;
      ak.add(akStock);

      // Curved magazine approximation
      const akMag = new THREE.Mesh(new THREE.BoxGeometry(0.09, 0.28, 0.16), black);
      akMag.position.set(0, -0.18, -0.05);
      akMag.rotation.z = Math.PI / 5;
      ak.add(akMag);

      // Grip
      const akGrip = new THREE.Mesh(new THREE.BoxGeometry(0.08, 0.16, 0.09), wood);
      akGrip.position.set(-0.02, -0.18, -0.12);
      akGrip.rotation.x = 0.05;
      ak.add(akGrip);

      // Subtle fore-end
      const akHandguard = new THREE.Mesh(new THREE.BoxGeometry(0.11, 0.09, 0.32), wood);
      akHandguard.position.set(0, 0, -0.65);
      ak.add(akHandguard);

      ak.position.set(0.42, -0.25, -0.9);
      ak.scale.set(1.1,1.1,1.1);
      weapons.ak.model = ak;
      ak.userData = ak.userData || {};
      ak.userData.isWeapon = true;
      akMag.userData = {origPosition: akMag.position.clone(), origRotation: akMag.rotation.clone()};
      weapons.ak.parts = {mag: akMag};
      // add small trigger and guard and ensure meshes cast/receive shadows
      const akTrigger = new THREE.Mesh(new THREE.BoxGeometry(0.03, 0.04, 0.02), darkMetal);
      akTrigger.position.set(-0.02, -0.08, -0.05);
      ak.add(akTrigger);
      const akTrigGuard = new THREE.Mesh(new THREE.TorusGeometry(0.035, 0.005, 8, 12, Math.PI), darkMetal);
      akTrigGuard.rotation.x = Math.PI / 2;
      akTrigGuard.position.set(0, -0.08, -0.05);
      ak.add(akTrigGuard);
      ak.traverse(m => { if (m.isMesh) { m.castShadow = true; m.receiveShadow = true; } });

      // Shotgun Model (pump-action visual)
      const sg = new THREE.Group();

      const sgBarrel = new THREE.Mesh(new THREE.CylinderGeometry(0.05, 0.05, 1.0, 16), metal);
      sgBarrel.rotation.x = Math.PI / 2;
      sgBarrel.position.set(0, 0, -1.05);
      sg.add(sgBarrel);

      const sgTube = new THREE.Mesh(new THREE.CylinderGeometry(0.045, 0.045, 0.85, 12), darkMetal);
      sgTube.rotation.x = Math.PI / 2;
      sgTube.position.set(0, -0.02, -0.85);
      sg.add(sgTube);

      const sgReceiver = new THREE.Mesh(new THREE.BoxGeometry(0.22, 0.14, 0.36), darkMetal);
      sgReceiver.position.set(0, -0.02, -0.25);
      sg.add(sgReceiver);

      const sgPump = new THREE.Mesh(new THREE.CylinderGeometry(0.06, 0.06, 0.36, 10), black);
      sgPump.rotation.x = Math.PI / 2;
      sgPump.position.set(0, -0.06, -0.6);
      sg.add(sgPump);

      const sgStock = new THREE.Mesh(new THREE.BoxGeometry(0.14, 0.1, 0.6), wood);
      sgStock.position.set(0.06, -0.02, 0.25);
      sg.add(sgStock);

      const sgGrip = new THREE.Mesh(new THREE.BoxGeometry(0.08, 0.18, 0.1), wood);
      sgGrip.position.set(-0.02, -0.16, -0.02);
      sg.add(sgGrip);

      sg.position.set(0.45, -0.28, -0.9);
      sg.scale.set(1.05,1.05,1.05);
      weapons.shotgun.model = sg;
      sg.userData = sg.userData || {};
      sg.userData.isWeapon = true;
      sgPump.userData = {origPosition: sgPump.position.clone()};
      weapons.shotgun.parts = {pump: sgPump};

      // Sniper Rifle Model (scoped bolt-action style)
      const sn = new THREE.Group();

      const snBarrel = new THREE.Mesh(new THREE.CylinderGeometry(0.028, 0.028, 1.4, 18), metal);
      snBarrel.rotation.x = Math.PI / 2;
      snBarrel.position.set(0, 0, -1.15);
      sn.add(snBarrel);

      const snMuzzle = new THREE.Mesh(new THREE.CylinderGeometry(0.06, 0.06, 0.2, 12), darkMetal);
      snMuzzle.rotation.x = Math.PI / 2;
      snMuzzle.position.set(0, 0, -1.55);
      sn.add(snMuzzle);

      const snReceiver = new THREE.Mesh(new THREE.BoxGeometry(0.26, 0.12, 0.42), metal);
      snReceiver.position.set(0, -0.02, -0.3);
      sn.add(snReceiver);

      const snStock = new THREE.Mesh(new THREE.BoxGeometry(0.16, 0.12, 0.8), black);
      snStock.position.set(0.06, -0.02, 0.35);
      sn.add(snStock);

      const snScope = new THREE.Mesh(new THREE.CylinderGeometry(0.045, 0.045, 0.44, 12), black);
      snScope.rotation.x = Math.PI / 2;
      snScope.position.set(0, 0.09, -0.4);
      sn.add(snScope);

      const snBolt = new THREE.Mesh(new THREE.BoxGeometry(0.04, 0.04, 0.18), darkMetal);
      snBolt.position.set(-0.06, 0.02, -0.25);
      sn.add(snBolt);

      const bipodLeg1 = new THREE.Mesh(new THREE.BoxGeometry(0.02, 0.2, 0.02), darkMetal);
      bipodLeg1.position.set(-0.05, -0.08, -0.6);
      bipodLeg1.rotation.z = Math.PI / 8;
      sn.add(bipodLeg1);

      const bipodLeg2 = bipodLeg1.clone();
      bipodLeg2.position.x = 0.05; bipodLeg2.rotation.z = -Math.PI / 8; sn.add(bipodLeg2);

      sn.position.set(0.38, -0.22, -1.05);
      sn.scale.set(1.0,1.0,1.0);
      weapons.sniper.model = sn;
      sn.userData = sn.userData || {};
      sn.userData.isWeapon = true;
      snReceiver.userData = {origPosition: snReceiver.position.clone()};
      weapons.sniper.parts = {receiver: snReceiver};
      // add scope lens detail and make sure meshes cast shadows
      const snScopeLens = new THREE.Mesh(new THREE.CircleGeometry(0.04, 16), new THREE.MeshStandardMaterial({color:0x111111, metalness:0.6, roughness:0.3, emissive:0x0a0a0a}));
      snScopeLens.rotation.x = -Math.PI/2;
      snScopeLens.position.set(0, 0.09, -0.2);
      sn.add(snScopeLens);
      sn.traverse(m => { if (m.isMesh) { m.castShadow = true; m.receiveShadow = true; } });
    }
    createWeaponModels();
    // Add current weapon to camera and ensure visibility
    camera.add(currentWeapon.model);
    if (currentWeapon.model.visible !== undefined) currentWeapon.model.visible = true;
    // ensure a canonical visible position so gun appears correctly
    currentWeapon.model.position.set(0.42, -0.25, -0.9);
    currentWeapon.model.userData = currentWeapon.model.userData || {};
    currentWeapon.model.userData.origPosition = currentWeapon.model.position.clone();

    // helper: hide any accidental player meshes (keeps camera + its children visible)
    function hidePlayerModelParts() {
      player.traverse(obj => {
        // skip the camera itself and everything that is a child of the camera
        if (obj === camera) return;
        // climb parents to see if this object (or its ancestor) is directly under the camera
        let p = obj.parent;
        let underCamera = false;
        while (p) { if (p === camera) { underCamera = true; break; } p = p.parent; }
        if (!underCamera) {
          // hide any visible meshes/groups that aren't part of the camera chain
          if (obj.visible !== undefined) obj.visible = false;
        }
      });
      // Also hide any non-weapon children of the camera (they can cause a visible 'thing' when looking down)
      function hideCameraNonWeaponParts() {
        const keep = [];
        if (weapons.ak && weapons.ak.model) keep.push(weapons.ak.model);
        if (weapons.shotgun && weapons.shotgun.model) keep.push(weapons.shotgun.model);
        if (weapons.sniper && weapons.sniper.model) keep.push(weapons.sniper.model);
        camera.children.forEach(ch => {
          // always preserve parts explicitly flagged as weapons
          if (ch.userData && ch.userData.isWeapon) { if (ch.visible !== undefined) ch.visible = true; return; }
          // keep known weapon model references
          if (keep.includes(ch)) { if (ch.visible !== undefined) ch.visible = true; return; }
          if (ch.isLight || ch.type === 'PerspectiveCamera' || ch.isCamera) return;
          if (ch.visible !== undefined) ch.visible = false;
        });
      }
      hideCameraNonWeaponParts();
      // expose for periodic use
      hidePlayerModelParts.hideCameraNonWeaponParts = hideCameraNonWeaponParts;
    }
    hidePlayerModelParts();

    // Weapon switching
    addEventListener("keydown", e => {
      keys[e.key.toLowerCase()] = true;
      if (e.key === "1") switchWeapon("ak");
      if (e.key === "2") switchWeapon("shotgun");
      if (e.key === "3") switchWeapon("sniper");

      if (e.key.toLowerCase() === "r" && !reloading && currentWeapon.ammo < currentWeapon.maxAmmo) {
        reloading = true;
        reloadCounter = currentWeapon.reloadTime;
        document.getElementById("reloadText").style.display = "block";
      }
    });
    addEventListener("keyup", e => keys[e.key.toLowerCase()] = false);

    function switchWeapon(name) {
      if (currentWeapon.model) camera.remove(currentWeapon.model);
      currentWeapon = weapons[name];
      camera.add(currentWeapon.model);
      if (currentWeapon.model.visible !== undefined) currentWeapon.model.visible = true;
      // reset to stored origin to avoid drift
      const orig = (currentWeapon.model.userData && currentWeapon.model.userData.origPosition) ? currentWeapon.model.userData.origPosition : new THREE.Vector3(0.35, -0.35, -0.6);
      currentWeapon.model.position.copy(orig);
      currentWeapon.model.userData = currentWeapon.model.userData || {};
      currentWeapon.model.userData.origPosition = orig.clone();

      // cancel any reload when switching to avoid weird states
      reloading = false;
      reloadCounter = 0;
      document.getElementById("reloadText").style.display = "none";

      document.getElementById("ammo").innerText = `Ammo: ${currentWeapon.ammo}/${currentWeapon.maxAmmo}`;
      // ensure player meshes remain hidden if something changed
      hidePlayerModelParts();
    }

    // ===== MOUSE CONTROL =====
    renderer.domElement.onclick = () => renderer.domElement.requestPointerLock();
    addEventListener("mousemove", e => {
      if (document.pointerLockElement === renderer.domElement && !dead) {
        yaw -= e.movementX * 0.0025;
        pitch -= e.movementY * 0.0025;
        pitch = Math.max(-1.5, Math.min(1.5, pitch));
      }
    });

    // ===== NPC SYSTEM =====
    let npcs = [];
    let bullets = [];

    function createHealthBar(color = 0x00ff00) {
      const bar = new THREE.Group();
      const bg = new THREE.Mesh(new THREE.PlaneGeometry(2, 0.25), new THREE.MeshBasicMaterial({color: 0xff0000}));
      bar.add(bg);
      const hp = new THREE.Mesh(new THREE.PlaneGeometry(2, 0.25), new THREE.MeshBasicMaterial({color: color}));
      hp.position.z = 0.01;
      bar.add(hp);
      bar.hp = hp;
      bar.position.y = 3.4;
      return bar;
    }

    function spawnNPC() {
      const npc = new THREE.Group();

      // Choose type: normal (green), speed (blue, faster), brute (red, double hp)
      const r = Math.random();
      let type = 'normal';
      if (r < 0.15) type = 'brute';
      else if (r < 0.4) type = 'speed';
      npc.type = type;

      // Visuals and size
      const bodyColor = type === 'speed' ? 0x2266ff : (type === 'brute' ? 0x660000 : 0x22aa22);
      const headColor = type === 'brute' ? 0x992222 : 0xffeeaa;
      // Make NPCs larger so they better match player character size
      const scale = type === 'brute' ? 2.2 : 1.8;

      // Body
      const body = new THREE.Mesh(new THREE.BoxGeometry(1.2 * scale, 1.6 * scale, 0.8 * scale), new THREE.MeshStandardMaterial({color: bodyColor}));
      body.position.y = 0.9 * scale;
      body.castShadow = true;
      npc.add(body);

      // Head
      const head = new THREE.Mesh(new THREE.BoxGeometry(0.8 * scale, 0.8 * scale, 0.8 * scale), new THREE.MeshStandardMaterial({color: headColor}));
      head.position.y = 1.9 * scale;
      head.castShadow = true;
      npc.add(head);

      // Arms
      const leftArm = new THREE.Mesh(new THREE.BoxGeometry(0.25 * scale, 0.9 * scale, 0.25 * scale), new THREE.MeshStandardMaterial({color: bodyColor}));
      leftArm.position.set(-0.7 * scale, 0.7 * scale, 0);
      leftArm.castShadow = true;
      npc.add(leftArm);

      const rightArm = leftArm.clone();
      rightArm.position.x = 0.7 * scale;
      npc.add(rightArm);

      // Legs
      const leftLeg = new THREE.Mesh(new THREE.BoxGeometry(0.35 * scale, 0.9 * scale, 0.35 * scale), new THREE.MeshStandardMaterial({color: 0x111111}));
      leftLeg.position.set(-0.25 * scale, 0.0, 0);
      leftLeg.castShadow = true;
      npc.add(leftLeg);
      const rightLeg = leftLeg.clone();
      rightLeg.position.x = 0.25 * scale;
      npc.add(rightLeg);

      // Eyes
      const eyeL = new THREE.Mesh(new THREE.SphereGeometry(0.06 * scale, 8, 8), new THREE.MeshStandardMaterial({color: 0x000000}));
      eyeL.position.set(-0.18 * scale, 1.95 * scale, 0.42 * scale);
      eyeL.castShadow = false;
      npc.add(eyeL);
      const eyeR = eyeL.clone();
      eyeR.position.x = 0.18 * scale;
      npc.add(eyeR);

      // Stats
      npc.maxHealth = type === 'brute' ? 200 : 100;
      npc.health = npc.maxHealth;
      // reduce top speed slightly and add a velocity vector for smoothing
      npc.speed = type === 'speed' ? 0.36 : 0.18; // speedsters move faster but less jittery
      npc.velocity = new THREE.Vector3();
      // keep NPCs a bit away and give them a detection/avoid radius
      npc.avoidDistance = 3.8 * scale;
      npc.detectionRadius = type === 'speed' ? 70 : (type === 'brute' ? 55 : 45);

      // Movement/wander AI state (make walk targets not too close to the player)
      function randomWalkTarget() {
        const t = new THREE.Vector3((Math.random() - 0.5) * 600, 0, (Math.random() - 0.5) * 600);
        if (t.distanceTo(player.position) < npc.avoidDistance + 12) {
          const dir = t.clone().sub(player.position).normalize().multiplyScalar(npc.avoidDistance + 22);
          t.copy(player.position).add(dir);
        }
        return t;
      }
      npc.walkTarget = randomWalkTarget();
      npc.walkTimer = 200 + Math.floor(Math.random() * 200);
      npc.legs = [leftLeg, rightLeg];

      // Health bar colored to type
      const hp = createHealthBar(type === 'speed' ? 0x2266ff : (type === 'brute' ? 0x992222 : 0x00ff00));
      npc.add(hp);
      // Raise healthbar to match scaled size
      hp.position.y = 3.4 * scale;
      npc.hpbar = hp;

      // Ensure spawn position is a minimum distance away from the player to avoid glitches
      const minSpawnDist = 18;
      let angle = Math.random() * Math.PI * 2;
      let dist = minSpawnDist + Math.random() * 380;
      npc.position.set(player.position.x + Math.cos(angle) * dist, 0, player.position.z + Math.sin(angle) * dist);
      // small random jitter so multiple NPCs don't stack exact coords
      npc.position.x += (Math.random() - 0.5) * 1.5;
      npc.position.z += (Math.random() - 0.5) * 1.5;

      // Delay initial shooting for ~3 seconds (180 frames)
      npc.cool = 180;
      scene.add(npc);
      npcs.push(npc);

      // Initial health bar setup
      npc.hpbar.hp.scale.x = npc.health / npc.maxHealth;
      npc.hpbar.hp.position.x = -1 + (npc.health / npc.maxHealth);
    }
    function maintainNPCs() {
      while (npcs.length < 20) spawnNPC();
    }
    maintainNPCs();

    // ===== RAYCAST SHOOTING =====
    const raycaster = new THREE.Raycaster();
    addEventListener("mousedown", e => {
      if (e.button === 0 && !dead) shoot();
    });

    function shoot() {
      if (reloading || currentWeapon.ammo <= 0) return;
      currentWeapon.ammo--;
      document.getElementById("ammo").innerText = `Ammo: ${currentWeapon.ammo}/${currentWeapon.maxAmmo}`;

      // recoil animation (reset to canonical z to avoid stacking offsets)
      currentWeapon.model.position.z -= 0.15;
      const resetZ = (currentWeapon.model.userData && currentWeapon.model.userData.origPosition) ? currentWeapon.model.userData.origPosition.z : currentWeapon.model.position.z + 0.15;
      setTimeout(() => currentWeapon.model.position.z = resetZ, 80);

      // Muzzle flash
      const flash = new THREE.PointLight(0xffaa00, 2, 10);
      flash.position.set(0.35, -0.35, -1);
      camera.add(flash);
      setTimeout(() => camera.remove(flash), 50);

      raycaster.setFromCamera(new THREE.Vector2(0, 0), camera);
      const hits = raycaster.intersectObjects(npcs, true);
      if (hits.length > 0) {
        // Find the top-level npc group from the hit
        let enemy = hits[0].object;
        while (enemy && !npcs.includes(enemy)) enemy = enemy.parent;
        if (enemy) {
          if (currentWeapon.name === "sniper") {
            enemy.health = 0; // one-shot
          } else {
            enemy.health -= currentWeapon.damage;
          }
          enemy.health = Math.max(0, enemy.health);
          const fraction = enemy.health / enemy.maxHealth;
          enemy.hpbar.hp.scale.x = fraction;
          enemy.hpbar.hp.position.x = -1 + fraction;
          if (enemy.health <= 0) {
            scene.remove(enemy);
            npcs.splice(npcs.indexOf(enemy), 1);
            score++;
          }
        }
      }
    }

    // ===== ENEMY SHOOT =====
    function enemyShoot(npc) {
      const color = npc.type === 'speed' ? 0x66ccff : (npc.type === 'brute' ? 0xff4444 : 0xff0000);
      const b = new THREE.Mesh(new THREE.SphereGeometry(0.25, 8, 8), new THREE.MeshBasicMaterial({color: color}));
      b.position.copy(npc.position);
      // Slow down enemy bullets
      const speed = npc.type === 'speed' ? 0.6 : 0.35;
      b.userData = {vel: player.position.clone().sub(npc.position).normalize().multiplyScalar(speed)};
      scene.add(b);
      bullets.push(b);
    }

    // ===== PLAYER DAMAGE =====
    function damagePlayer() {
      if (respawnProtection > 0 || damageCooldown > 0) return;
      health--;
      damageCooldown = 45;
      document.getElementById("health").style.width = (health / 3 * 100) + "%";
      if (health <= 0) die();
    }

    // ===== DEATH =====
    function die() {
      dead = true;
      document.exitPointerLock();
      document.getElementById("death").style.display = "flex";
      if (score > highscore) highscore = score;
      document.getElementById("scoreText").innerText = "Score: " + score;
      document.getElementById("highText").innerText = "High Score: " + highscore;
    }

    // ===== RESPAWN =====
    function respawn() {
      dead = false;
      score = 0;
      health = 3;
      document.getElementById("health").style.width = "100%";
      player.position.set(0, 5, 20);
      yaw = 0;
      pitch = 0;
      bullets.forEach(b => scene.remove(b));
      bullets = [];
      npcs.forEach(n => scene.remove(n));
      npcs = [];
      maintainNPCs();
      respawnProtection = 180;
      document.getElementById("death").style.display = "none";
      renderer.domElement.requestPointerLock();
    }

    // ===== HANDLE RELOAD =====
    function handleReload() {
      if (reloading) {
        reloadCounter--;
        const elapsed = currentWeapon.reloadTime - Math.max(0, reloadCounter);
        const progress = Math.min(1, elapsed / currentWeapon.reloadTime);
        document.getElementById("reloadText").style.display = "block";
        document.getElementById("reloadText").innerText = `Reloading... ${Math.round(progress * 100)}%`;

        const parts = currentWeapon.parts || {};
        // Per-weapon visual motion synchronized to reload progress
        if (currentWeapon.name === "AK" && parts.mag) {
          parts.mag.rotation.x = parts.mag.userData.origRotation.x - Math.sin(progress * Math.PI) * 0.8;
          parts.mag.position.y = parts.mag.userData.origPosition.y + Math.sin(progress * Math.PI) * 0.05;
        } else if (currentWeapon.name === "Shotgun" && parts.pump) {
          parts.pump.position.z = parts.pump.userData.origPosition.z + Math.sin(progress * Math.PI) * -0.15;
        } else if (currentWeapon.name === "Sniper" && parts.receiver) {
          parts.receiver.position.z = parts.receiver.userData.origPosition.z + Math.sin(progress * Math.PI) * -0.25;
        } else if (currentWeapon.model) {
          currentWeapon.model.position.y = -0.35 + Math.sin(progress * Math.PI) * 0.05;
        }

        if (reloadCounter <= 0) {
          currentWeapon.ammo = currentWeapon.maxAmmo;
          reloading = false;
          // reset parts to original transforms
          if (parts.mag && parts.mag.userData.origRotation) parts.mag.rotation.copy(parts.mag.userData.origRotation);
          if (parts.mag && parts.mag.userData.origPosition) parts.mag.position.copy(parts.mag.userData.origPosition);
          if (parts.pump && parts.pump.userData.origPosition) parts.pump.position.copy(parts.pump.userData.origPosition);
          if (parts.receiver && parts.receiver.userData.origPosition) parts.receiver.position.copy(parts.receiver.userData.origPosition);
          if (currentWeapon.model) currentWeapon.model.position.set(0.35, -0.35, -0.6);
          document.getElementById("ammo").innerText = `Ammo: ${currentWeapon.ammo}/${currentWeapon.maxAmmo}`;
          document.getElementById("reloadText").style.display = "none";
        }
      }
    }

    // ===== UPDATE LOOP =====
    function update() {
      if (damageCooldown > 0) damageCooldown--;
      handleReload();
      if (dead) return;
      if (respawnProtection > 0) respawnProtection--;

      player.rotation.y = yaw;
      camera.rotation.x = pitch;

      // sprint
      let sprint = keys["shift"] && stamina > 0;
      let speed = sprint ? 0.6 : 0.25;
      if (sprint) stamina -= 0.7;
      else stamina += 0.4;
      stamina = Math.max(0, Math.min(100, stamina));
      document.getElementById("stamina").style.width = stamina + "%";

      const forward = new THREE.Vector3(0, 0, -1).applyQuaternion(player.quaternion);
      const right = new THREE.Vector3(1, 0, 0).applyQuaternion(player.quaternion);
      if (keys["w"]) player.position.add(forward.clone().multiplyScalar(speed));
      if (keys["s"]) player.position.add(forward.clone().multiplyScalar(-speed));
      if (keys["a"]) player.position.add(right.clone().multiplyScalar(-speed));
      if (keys["d"]) player.position.add(right.clone().multiplyScalar(speed));

      // jump
      if (keys[" "] && onGround) {
        velY = 0.35;
        onGround = false;
      }
      velY -= 0.02;
      player.position.y += velY;
      if (player.position.y <= 5) {
        player.position.y = 5;
        velY = 0;
        onGround = true;
      }

      // NPC behavior (wandering + chasing)
      npcs.forEach(n => {
        const dist = n.position.distanceTo(player.position);
        n.hpbar.quaternion.copy(camera.quaternion);

        // Wandering timer decrement (target selection handled below)
        n.walkTimer--;

        // If close to player, chase (but keep a safe distance); otherwise head to walkTarget
        if (dist < n.detectionRadius) {
          // chase behavior â€” smooth acceleration toward player, stop before avoidDistance
          const dir = player.position.clone().sub(n.position);
          dir.y = 0;
          const desired = dir.clone();
          const dlen = desired.length();
          if (dlen > 0.001) desired.normalize();

          if (dlen > n.avoidDistance + 0.6) {
            const desiredVel = desired.multiplyScalar(n.speed * (n.type === 'speed' ? 1.25 : 1.0));
            n.velocity.lerp(desiredVel, 0.18);
            n.position.add(n.velocity);
            n.rotation.y = Math.atan2(n.velocity.x, n.velocity.z);
          } else {
            // back away smoothly
            const away = n.position.clone().sub(player.position);
            away.y = 0;
            if (away.length() === 0) away.set(Math.random() - 0.5, 0, Math.random() - 0.5);
            away.normalize();
            const awayVel = away.multiplyScalar(n.speed * 0.6);
            n.velocity.lerp(awayVel, 0.2);
            n.position.add(n.velocity);
            n.rotation.y = Math.atan2(n.velocity.x, n.velocity.z);
          }

          // leg animation scaled by actual velocity to avoid jitter
          if (n.legs) {
            const t = performance.now() * 0.005;
            const moveSpeed = Math.min(1.5, n.velocity.length() * 6);
            n.legs.forEach((leg, i) => leg.rotation.x = Math.sin(t * 6 + i) * 0.6 * moveSpeed);
          }
        } else {
          // walking toward walkTarget with smoothing
          if (n.walkTimer <= 0 || n.position.distanceTo(n.walkTarget) < 2) {
            const t = new THREE.Vector3((Math.random() - 0.5) * 600, 0, (Math.random() - 0.5) * 600);
            if (t.distanceTo(player.position) < n.avoidDistance + 10) {
              const dir = t.clone().sub(player.position).normalize().multiplyScalar(n.avoidDistance + 20);
              t.copy(player.position).add(dir);
            }
            n.walkTarget.copy(t);
            n.walkTimer = 200 + Math.floor(Math.random() * 200);
          }

          const dir = n.walkTarget.clone().sub(n.position);
          dir.y = 0;
          if (dir.length() > 0.1) {
            const desiredVel = dir.normalize().multiplyScalar(n.speed);
            n.velocity.lerp(desiredVel, 0.12);
            n.position.add(n.velocity);
            n.rotation.y = Math.atan2(n.velocity.x, n.velocity.z);
            if (n.legs) {
              const t = performance.now() * 0.005;
              const moveSpeed = Math.min(1.2, n.velocity.length() * 6);
              n.legs.forEach((leg, i) => leg.rotation.x = Math.sin(t * 6 + i) * 0.6 * moveSpeed);
            }
          }
        }

        // Shooting
        n.cool--;
        // Don't allow NPCs to shoot during player's respawn protection and wait the initial delay
        if (dist < 120 && n.cool <= 0 && respawnProtection <= 0) {
          enemyShoot(n);
          n.cool = n.type === 'speed' ? 90 : 120;
        }
      });
      maintainNPCs();

      // bullets
      // tidy up bullets safely (iterate backwards so removals don't skip)
      for (let i = bullets.length - 1; i >= 0; i--) {
        const b = bullets[i];
        b.position.add(b.userData.vel);
        if (b.position.distanceTo(player.position) < 1.5) {
          damagePlayer();
          scene.remove(b);
          bullets.splice(i, 1);
          continue;
        }
        // remove stray bullets that go too far away to keep array small
        if (b.position.distanceTo(player.position) > 1200) {
          scene.remove(b);
          bullets.splice(i, 1);
          continue;
        }
      }

      // periodic camera sanity check to remove any non-weapon children that cause artifacts when looking down
      cameraSanityTimer++;
      if (cameraSanityTimer % 60 === 0) {
        if (hidePlayerModelParts && hidePlayerModelParts.hideCameraNonWeaponParts) hidePlayerModelParts.hideCameraNonWeaponParts();
      }

      // Update HUD scores
      const cs = document.getElementById("currentScore");
      const hs = document.getElementById("highScore");
      if (cs) cs.innerText = `Score: ${score}`;
      if (hs) hs.innerText = `High Score: ${highscore}`;

    }

    // Background music: attempt autoplay, fallback to click-resume (song.mp3 in same folder)
    const bgMusic = new Audio('song.mp3');
    bgMusic.loop = true;
    bgMusic.volume = 0.35;
    function tryPlayBackgroundMusic() {
      bgMusic.play().catch(() => {
        // Autoplay blocked; allow a user gesture to start playback once
        renderer.domElement.addEventListener('click', function oncePlay() {
          bgMusic.play();
          renderer.domElement.removeEventListener('click', oncePlay);
        }, { once: true });
      });
    }
    tryPlayBackgroundMusic();

    // ===== ANIMATION LOOP =====
    function animate() {
      requestAnimationFrame(animate);
      update();
      renderer.render(scene, camera);
    }
    animate();

    // ===== RESIZE =====
    addEventListener("resize", () => {
      camera.aspect = innerWidth / innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(innerWidth, innerHeight);
    });
  </script>
</body>
</html>